# -*- coding: utf-8 -*-
"""Time_Series_IDCamp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nVKN9uQTA3M5m39VtGPwMr9RM_e9hTms

# IMPORT LIBRARY
"""

#Library Umum Pengolahan data dan Proses Matematika
import math
import numpy as np
import pandas as pd

#Library untuk melakukan Visualisasi
import matplotlib.pyplot as plt

#Library untuk Pembuatan Model
import tensorflow as tf
from keras.layers import Dense, LSTM

#Library uji Augmented Dickey-Fuller (data Stasionary)
from statsmodels.tsa.stattools import adfuller

#Library evaluasi model dengan MAE
from sklearn import metrics

#Library untuk Split Data
from sklearn.model_selection import train_test_split

"""## Download Dataset


*   Download: [Stock_Microsoft](https://www.kaggle.com/datasets/vijayvvenkitesh/microsoft-stock-time-series-analysis/data)
*   Upload Data ke Google Coolab

## Load Data
"""

df = pd.read_csv('Microsoft_Stock.csv')
df

"""# Explore Data

## Check Ukuran Data
"""

df.info()

df.shape

"""## Check Nilai yang Kosong"""

df.isnull().sum()

"""## Check describe Data"""

df.describe()

"""# Visualisasi Data
##Visualisasi Colum Close
"""

df['Close'].plot(figsize=(7, 5))

"""##Visualisasi Data Column Close, Low, dan High"""

#Menghapus info waktu pada colum Date
df['Date'] = pd.to_datetime(df['Date']).dt.date.astype('datetime64[ns]')
df.head()

#menetapkan kolom Date sebagai indeks dari dataframe
df.set_index("Date", inplace=True)
df

#melakukan visualisasi dengan rentang waktu 3 bulan
df[['High','Open','Low']].resample(rule='q').mean().plot(kind='bar',figsize=(15,5))

"""# Visualisasi Rolling Mean dan Standrt Deviation
##Rolling Mean dan Standart Deviation setiap 1 tahun
"""

df_yearly = df.copy()
mean_y = df_yearly['High:365 days mean']=df['High'].rolling(365).mean()
std_y = df_yearly['High:365 days std']=df['High'].rolling(365).std()

df_yearly.head()

df_yearly[['High','High:365 days mean', 'High:365 days std']].plot(figsize=(8,5))

"""## Rolling Mean dan Standart Devation Setiap 3 bulan"""

df_quarterly = df.copy()
mean_q = df_quarterly['High:90 days mean']=df['High'].rolling(90).mean()
std_y = df_quarterly['High:90 days std']=df['High'].rolling(90).std()

df_yearly.head()

df_quarterly[['High','High:90 days mean', 'High:90 days std']].plot(figsize=(8,5))

"""# Check Sationary"""

print('Results of Dickey Fuller Test:')
adftest = adfuller(df['Close'], autolag='AIC')

adf_stat = adftest[0]
p_value = adftest[1]
num_lags = adftest[2]
num_obs = adftest[3]
critical_values = adftest[4]

adfoutput = pd.Series([adf_stat, p_value, num_lags, num_obs],
                     index=['Test Statistic','p-value','#Lags Used','Number of Observations Used'])

for significance_level, critical_value in critical_values.items():
    adfoutput[f"Critical Value ({significance_level}%)"] = critical_value

if p_value <= 0.05:
    print("Data Stasioner, Berdasarkan data berikut")
else:
    print("Data tidak Stasioner, Berdasarkan data berikut")

print(adfoutput)

#Data Cleaning
df = df.dropna(how='any',axis=0)
df.isna().sum()

"""# Proccesing Data
##Split data Training dan Data Validasi

"""

series = df['Close'].values

# Train : Validation = 80 : 20
batas = math.ceil(0.8 * len(series))
x_train = series[:batas]
x_val = series[batas:]

print(np.min(x_train))
print(np.max(x_train))
print(x_train.shape)
print(x_val.shape)

"""## Normalisasi data dengan MIn-Max
![image.png](data:image/png;base64,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)
"""

min_train = np.min(x_train)
max_train = np.max(x_train)
x_train = x_train - min_train
x_train = x_train / (max_train - min_train)

x_val = x_val - min_train
x_val = x_val /(max_train - min_train)

# Sample x_train
print("Sample x_train", x_train[:5])
print("Sample x_test", x_val[:5])

print(np.min(x_train))
print(np.max(x_train))

"""## Windowing Data"""

def windowed_dataset(series, window_size, batch_size, shuffle_buffer):
    series = tf.expand_dims(series, axis=-1)
    ds = tf.data.Dataset.from_tensor_slices(series)
    # +1 pada window_size untuk menambahkan label dari [X] menjadi [X, y] contoh X dan y bisa dilihat di atas.
    ds = ds.window(window_size + 1, shift=1, drop_remainder=True)
    ds = ds.flat_map(lambda w: w.batch(window_size + 1))
    ds = ds.shuffle(shuffle_buffer) # Comment bagian ini untuk melihat pola yang dihasilkan dari windowed dataset
    ds = ds.map(lambda w: (w[:-1], w[-1:]))
    return ds.batch(batch_size).prefetch(1) # prefetch digunakan untuk optimalisasi proses batching

window_size = 10

# Dapat disesuaikan dengan trial error
train_set = windowed_dataset(
    x_train,
    window_size=window_size,
    batch_size=16,
    shuffle_buffer=1000
)

val_set = windowed_dataset(
    x_val,
    window_size=window_size,
    batch_size=16,
    shuffle_buffer=1000
)

sample_batch1_train = list(train_set.take(1).as_numpy_iterator())
sample_pasangan_xy_train = sample_batch1_train[0][0][0], sample_batch1_train[0][1][0]
print("Sample ke-1 (X, y) pada batch ke-1 train_set", sample_pasangan_xy_train)

sample_pasangan_xy_train = sample_batch1_train[0][0][1], sample_batch1_train[0][1][1]
print("Sample ke-2 (X, y) pada batch ke-1 train_set", sample_pasangan_xy_train)

"""#Proses Model
##Pembuatan Model
"""

model = tf.keras.models.Sequential([
  tf.keras.layers.LSTM(50, activation='relu', input_shape=(10, 1)),
  tf.keras.layers.RepeatVector(10),
  tf.keras.layers.LSTM(200, activation='relu', return_sequences=True),
  tf.keras.layers.Dropout(0.5),
  tf.keras.layers.Dense(16, activation="relu"),
  tf.keras.layers.Dense(8, activation="relu"),
  tf.keras.layers.TimeDistributed(Dense(1)),
  ])

"""##Optimizer"""

optimizer = tf.keras.optimizers.SGD(learning_rate=1.0000e-04, momentum=0.9)
model.compile(loss=tf.keras.losses.Huber(),
              optimizer='adam',
              metrics=["mae"])

threshold_mae = (np.max(x_train) - np.min(x_train)) * 10 / 100
print("Treshold MAE:", threshold_mae)

"""##Pembuatan Callback"""

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if logs.get('mae') < threshold_mae and logs.get('val_mae') < threshold_mae:
      print(f"\MAE dan Val MAE telah kurang dari batas 10% skala data ({threshold_mae})")
      self.model.stop_training = True

callback_mae = myCallback()

"""##Training Model"""

history = model.fit(
    train_set,
    epochs=500,
    validation_data=val_set,
    callbacks=[callback_mae],
    verbose=2
)

"""#Visualisasi MAE dan Loss"""

plt.plot(history.history['loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train'], loc='upper right')
plt.show()

plt.plot(history.history['mae'])
plt.title('Model MAE')
plt.ylabel('MAE')
plt.xlabel('Epoch')
plt.legend(['Train'], loc='lower right')
plt.show()

